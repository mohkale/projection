#+TITLE: Projection
#+AUTHOR: Mohsin Kaleem
# LocalWords: pluggable ibuffer

#+html: <p align="right">
#+html: <a href="https://github.com/mohkale/projection" alt="lint" style="margin-right: 4px;"><img src="https://github.com/mohkale/projection/actions/workflows/lint.yml/badge.svg" /></a>
#+html: <a href="https://github.com/mohkale/projection" alt="test" style="margin-right: 4px;"><img src="https://github.com/mohkale/projection/actions/workflows/test.yml/badge.svg" /></a>
#+html: <a href="https://melpa.org/#/projection"><img alt="MELPA" src="https://melpa.org/packages/projection-badge.svg"/></a>
#+html: </p>

Project type support for Emacs builtin ~project.el~.

This Emacs package provides a [[https://github.com/bbatsov/projectile][Projectile]] like project management library built atop
Emacs built-in ~project.el~. The end goal is to provide a stable and reliable
out-of-the-box project management experience for as many project types as possible.

* The Why?
  Projectile is *fantastic!* The out of the box experience is amazing, but it's also
  quite overbearing. Currently projectile has almost 6000 lines of source code all
  contained in a single file. This includes cross-platform facilities for detecting
  the current project root, definitions for numerous project types, and a myriad of
  helper functions (such as a pluggable TAGS table back-end, or wrappers across other
  Emacs commands or packages with the sole amendment being they run in the project
  root). Suffice it to say I think projectile is /spread a little too thin and trying
  to do way too much/. This is a consequence of it evolving naturally from a time when
  Emacs had poor built-in project support. Going forward I expect more packages to
  start using the new built-in Emacs ~project.el~ and Projectile becoming yet-another
  pluggable backend for it. In that vein this project is simply trying to migrate
  over the minimum feature set I find valuable from Projectile for my personal use.
  Where possible I do also try to improve on features. For example Projectile doesn't
  support binding an interactive function as a compilation command (like
  ~rustic-compile~) but Projection does.

  *Note*: If any part of this description is no longer up-to-date please open a PR to
  discuss updating it :-).

* Features
** Projection Commands
   This feature works just like projectiles ~projectile-compile-project~ family of
   commands, with projects being allowed to optionally define commands for
   configuring, building, running and testing the current project.

   *Note*: Projection supports both shell-commands, interactive functions and helper
   functions which can return either of these as valid targets for each of these
   commands. This means, for example, we can support using rustic-modes builtin
   compilation commands and fallback to basic shell-commands when those aren't
   defined. See [[file:src/projection-types.el][projection-types]] for how this is configured.

   You can also customise these commands on a project-by-project basis by using a
   directory-local variable for each of them or by passing a prefix-argument to the
   command (Example: ~C-u M-x projection-build-project~) which will result in projection
   prompting you for a command and then caching it to make sure it's used the next
   time you run that command.

   If a project-type doesn't define a default for one of these commands, for example
   if it doesn't support configuring as an independent step, then the respective
   projection command will fail.

** Projection Hook
   Provides a more general purpose parallel to ~projectile-toggle-project-read-only~.
   With this you can hook certain functions (Example: ~read-only-mode~) into a project
   and retroactively apply it to both all the open buffers from that project and any
   new buffers that will be opened in it.

** Projection Find
   Adds facilities for jumping to related files within a project. The most common use
   case for this would be jumping between C++ header ~.h~ and implementation ~.cpp~ files.
   This is already possible with Emacs's builtin =ff-find-other-file= command but
   projection builds on top of it by supporting jumping to related files in other
   directories or with alterations to the file-name beyond extensions. For example if
   you have header files in an include directory and implementation files in a src
   directory then =projection-find-other-file= can still jump between them without any
   extra configuration. If you're working on a python project and define test files
   with a ~test_BASENAME.py~ format then ~projection-find-other-file~ can also jump
   between ~BASENAME.py~ and ~test_BASENAME.py~. ~projection-find-other-file~ is intended to
   be a consistent and transitive command. You can invoke it repeatedly to cycle
   between related files and the order in which you cycle will be consistent
   independent of which file you're currently in.

   General associations between the current files extension and possible related file
   extensions is configured in =projection-find-other-file-suffix=. Supported suffixes
   and prefixes for test files is configured by the project-type in
   [[file:src/projection-types.el]].

** Projection ibuffer
   Offers variants of ~projectile-ibuffer~ and the [[https://github.com/purcell/ibuffer-projectile][ibuffer-projectile]] project in the
   form of =ibuffer-projection-current-project= and =ibuffer-projection-set-filter-groups=.
   The former creates and displays a dedicated ibuffer window for only buffers in the
   current project. The latter pre-pends filters to group by a specific project for
   all currently open projects.

** Projection multi-compile
   compile-multi is a [[https://github.com/mohkale/compile-multi][package]] that supports auto extracting compilation commands from
   the current project (for example from Makefiles) and lets you interactively select
   one to run. Projection is designed to be a generic frontend for numerous project
   types, not an extractor for the specific compilation targets a given project
   defines. However projection does expose a ~projection-multi-compile~ command that
   wraps around ~compile-multi~. It uses this to inject compilation target definitions
   for projection itself (for example "project:build" is offered to run
   ~projection-build-project~ for projects that have a configured build command) and
   also for build frameworks projection is aware of (such as Make or CMake).

** Projection recentf
   A variant of =M-x recentf= for files exclusively in the current project.
